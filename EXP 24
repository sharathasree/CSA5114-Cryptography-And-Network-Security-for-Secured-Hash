#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
int factor_n(uint64_t n, uint64_t *p, uint64_t *q) {
    uint64_t limit = (uint64_t)floor(sqrt((double)n));
    for (uint64_t a = 2; a <= limit; ++a) {
        if (n % a == 0) {
            *p = a;
            *q = n / a;
            return 1;
        }
    }
    return 0;
}
int64_t extended_gcd(int64_t a, int64_t b, int64_t *x, int64_t *y) {
    if (b == 0) {
        *x = (a >= 0) ? 1 : -1;
        *y = 0;
        return llabs(a);
    }
    int64_t x1 = 0, y1 = 0;
    int64_t g = extended_gcd(b, a % b, &x1, &y1);
    *x = y1;
    *y = x1 - (a / b) * y1;
    return g;
}
int modinv(int64_t a, int64_t m, int64_t *inv) {
    int64_t x=0, y=0;
    int64_t g = extended_gcd(a, m, &x, &y);
    if (g != 1) return 0; /* inverse doesn't exist */
    int64_t res = x % m;
    if (res < 0) res += m;
    *inv = res;
    return 1;
}

uint64_t modexp(uint64_t base, uint64_t exp, uint64_t mod) {
    uint64_t res = 1 % mod;
    base %= mod;
    while (exp) {
        if (exp & 1) res = ( (__uint128_t)res * base ) % mod;
        base = ( (__uint128_t)base * base ) % mod;
        exp >>= 1;
    }
    return res;
}

int main(void) {
    uint64_t n = 3599;
    uint64_t e = 31;

    uint64_t p = 0, q = 0;
    if (!factor_n(n, &p, &q)) {
        fprintf(stderr, "Failed to factor n = %llu\n", (unsigned long long)n);
        return 1;
    }

    if (p > q) { uint64_t t = p; p = q; q = t; }

    uint64_t phi = (p - 1) * (q - 1);

    int64_t d = 0;
    if (!modinv((int64_t)e, (int64_t)phi, &d)) {
        fprintf(stderr, "Modular inverse of e mod phi does not exist\n");
        return 1;
    }

    printf("Public key:  e = %llu\n", (unsigned long long)e);
    printf("            n = %llu\n\n", (unsigned long long)n);
    printf("Found factors: p = %llu, q = %llu\n", (unsigned long long)p, (unsigned long long)q);
    printf("phi(n) = (p-1)*(q-1) = %llu\n\n", (unsigned long long)phi);
    printf("Private key d (modular inverse of e mod phi) = %lld\n\n", (long long)d);

    uint64_t m = 1234 % n;
    uint64_t c = modexp(m, e, n);
    uint64_t m_rec = modexp(c, (uint64_t)d, n);
    printf("Test message m = %llu\n", (unsigned long long)m);
    printf("Encrypted c = m^e mod n = %llu\n", (unsigned long long)c);
    printf("Decrypted m' = c^d mod n = %llu\n", (unsigned long long)m_rec);

    return 0;
}
