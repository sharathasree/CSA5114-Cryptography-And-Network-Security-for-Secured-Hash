#include <stdio.h>
#include <stdint.h>

uint64_t gcd(uint64_t a, uint64_t b) {
    while (b != 0) {
        uint64_t t = b;
        b = a % b;
        a = t;
    }
    return a;
}
int64_t extended_gcd(int64_t a, int64_t b, int64_t *x, int64_t *y) {
    if (b == 0) {
        *x = 1;
        *y = 0;
        return a;
    }
    int64_t x1, y1;
    int64_t g = extended_gcd(b, a % b, &x1, &y1);

    *x = y1;
    *y = x1 - (a / b) * y1;
    return g;
}

int64_t mod_inverse(int64_t e, int64_t phi) {
    int64_t x, y;
    int64_t g = extended_gcd(e, phi, &x, &y);
    if (g != 1) return -1;  // no inverse
    x %= phi;
    if (x < 0) x += phi;
    return x;
}

int main() {
    uint64_t n = 3599;       
    uint64_t e = 31;         

    uint64_t known_plaintext = 59;  

    uint64_t factor = gcd(known_plaintext, n);

    if (factor == 1) {
        printf("No help. Plaintext is coprime with n.\n");
        return 0;
    }

    printf("Found a nontrivial gcd! Factor = %llu\n", (unsigned long long)factor);

    uint64_t p = factor;
    uint64_t q = n / p;

    printf("Recovered factors: p = %llu, q = %llu\n",
           (unsigned long long)p, (unsigned long long)q);

    uint64_t phi = (p - 1) * (q - 1);
    printf("phi(n) = %llu\n", (unsigned long long)phi);

    int64_t d = mod_inverse(e, phi);
    printf("Recovered private key d = %lld\n", (long long)d);

    return 0;
}
